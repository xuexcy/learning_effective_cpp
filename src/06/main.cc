/**
########################################################################
#
# Copyright (c) 2024 xx.com, Inc. All Rights Reserved
#
########################################################################
# Author  :   xuechengyun
# E-mail  :   xuechengyun@gmail.com
# Date    :   2024/11/21 20:22:46
# Desc    :   item 06: 若不想使用编译器自动生成的函数，就该明确拒绝(Explicitly disallow the use of compiler-generated functions you do not want)
########################################################################
*/

// part-1
// 编译器会为 class 生成 copy constructor 和 copy assignment operator (比如 bad_case::HomeForSale)，
// 如果我们不需要，可以将它们声明为 private (比如 solution::HomeForSale)，这样使用它们就会导致编译错误，或者链接
// 错误(如果是 friend 或类里面的其他函数，它们是可以使用这两个函数的，因为 private 对它们不生效，但是由于我们只是声
// 明了两个 copy 函数，没有定义它们，这会导致 friend 或类中的其他函数在使用时编译成功但链接失败)
namespace bad_case {
class HomeForSale {
};  // class HomeForSale

void run() {
    HomeForSale h1;
    HomeForSale h2(h1);  // copy constructor generated by compiler
    h2 = h1;  // copy assignment operator generated by compiler
}

}  // namespace bad_case

namespace solution_1 {
class HomeForSale {
public:
    // 这里必须要有用户可用的构造函数，因为在有 private copy constructor 的情况下，编译器不会生成其他构造函数
    // 否则就不能构造 class 的实例
    HomeForSale() = default;
    static void run() {
        HomeForSale h1;
        /** 如果有其他 friend 如此使用，也会链接出错，
        因为 copy constructor/assignment 只有声明，没有定义
        Undefined symbols for architecture arm64:
            "solution_1::HomeForSale::HomeForSale(solution_1::HomeForSale const&)", referenced from:
                solution_1::HomeForSale::run() in ccVnikBe.o
        ld: symbol(s) not found for architecture arm64
        */
        // HomeForSale h2(h1);
    }
private:
    HomeForSale(const HomeForSale&);
    HomeForSale& operator=(const HomeForSale&);

};  // class HomeForSale
void run() {
    HomeForSale h1;
    /** 编译出错
    error: 'solution_1::HomeForSale::HomeForSale(const solution_1::HomeForSale&)' is private within this context
    */
    // HomeForSale h2(h1);

    HomeForSale::run();
}
}  // namespace solution_1

// part-2
// 为了让使用 copy constructor 和 copy assignment operator 时直接编译失败，可以使用 class Uncopyable，
// 并由继承类继承两个 private copy 函数，这样就可以解决 solution_1 中在链接时才出错的问题
namespace solution_2 {
class Uncopyable {
protected:
    Uncopyable() = default;
    ~Uncopyable() = default;
private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};  // class Uncopyable

class HomeForSale : private Uncopyable {
public:
    static void run() {
        HomeForSale h1;
        /* compile error */
        // HomeForSale h2(h1);
    }
};  // class HomeForSale

void run() {
    HomeForSale h1;
    {
        /* compile error */
        // HomeForSale h2(h1);
    }
    {
        HomeForSale h2;
        /* compile error */
        // h3 = h1;
    }
    HomeForSale::run();
}

}  // namespace solution_2


int main() {
    bad_case::run();
    solution_1::run();
    solution_2::run();
    return 0;
}

